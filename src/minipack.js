/**
 * モジュールバンドラーは、小さなコード片を、ウェブブラウザで動作する、より
 * 大きく複雑なものへとコンパイルします。この小さなコード片とは JavaScript
 * ファイルのことであり、各ファイルの依存関係はモジュールシステムによって
 * 表現されます (https://webpack.js.org/concepts/modules)。
 *
 * モジュールバンドラーはエントリーファイルという概念をもちます。いくつかの
 * script タグをブラウザに追加してそれらを実行する代わりに、どれが
 * アプリケーションのメインファイルなのかをバンドラーに知らせるのです。
 * このファイルはアプリケーション全体を起動させるファイルです。
 *
 * 私たちのバンドラーは、エントリーファイルからスタートし、それが他のどの
 * ファイルに依存しているのかを確認します。続いて、その依存対象が依存している
 * ファイルを確認します。アプリケーションのすべてのモジュールが互いに
 * どのように依存しあっているのかを把握できるまで、上の工程を繰り返します。
 *
 * このようにして得られるプロジェクトの全体像は、依存グラフと呼ばれます。
 *
 * 以下の例では、私たちは依存グラフを作成し、それを用いてすべてのモジュールを
 * 一つのバンドルへとまとめ上げます。
 *
 * 始めましょう :)
 *
 * 注意点: これはとても簡略化された例です。できる限り例をシンプルに保つため、
 * 依存の循環への対処、エクスポートされるモジュールのキャッシュ、
 * 各モジュールを一度だけパースすること、等々は考慮されていません。
 */

const fs = require('fs');
const path = require('path');
const babylon = require('babylon');
const traverse = require('babel-traverse').default;
const {transformFromAst} = require('babel-core');

let ID = 0;

// ファイルへのパスを受け取り、その中身を読み込み、依存対象を抜き出す関数を
// まず作成します。
function createAsset(filename) {
  // ファイルの中身を文字列として読み込みます。
  const content = fs.readFileSync(filename, 'utf-8');

  // ここで、このファイルが他のどのファイルに依存しているのかを確認します。
  // import という文字列を探すことでも可能ですが、これは少し不格好なため、
  // 代わりに JavaScript パーサーを使うことにします。
  //
  // JavaScript パーサーは、JavaScript のコードを読み込んで理解するための
  // ツールです。AST (抽象構文木) と呼ばれる、より抽象的なモデルを生成します。

  // AST の見た目を確認するために、AST Explorer (https://astexplorer.net) を
  // 見てみることを強くおすすめします。
  //
  // AST は、私たちのコードに関する多くの情報を含んでいます。AST に対し、
  // コードがおこなおうとしていることを問い合わせることができます。
  const ast = babylon.parse(content, {
    sourceType: 'module',
  });

  // この配列は、このモジュールが依存するモジュールの相対パスを格納します。
  const dependencies = [];

  // このモジュールが依存するモジュールを把握するために、AST を走査します。
  // そのために、AST に含まれるすべてのインポート宣言をチェックします。
  traverse(ast, {
    // EcmaScript モジュールは静的であるためとても簡単です。つまり、変数を
    // インポートしたり、条件に応じて他のモジュールをインポートすることはできません。
    // インポート文を見たら、その値が依存対象であると考えればよいのです。
    ImportDeclaration: ({node}) => {
      // インポートする値を、依存対象を格納する配列に追加します。
      dependencies.push(node.source.value);
    },
  });

  // シンプルなカウンターを増加させ、このモジュールにユニークな ID を割り当てます。
  const id = ID++;

  // 私たちは、EcmaScript モジュールや、すべてのブラウザではサポートされていない
  // JavaScript の他の機能を使用します。バンドルがすべてのブラウザで実行できる
  // ように、これを Babel によりトランスパイルします
  // (https://babeljs.io を確認してください)。
  //
  // `presets` オプションは、コードのトランスパイルの仕方を Babel に伝える
  // ルールのセットです。大方のブラウザが実行できるものへとコードを
  // トランスパイルするために、ここでは `babel-preset-env` を使用します。
  const {code} = transformFromAst(ast, null, {
    presets: ['env'],
  });

  // このモジュールに関するすべての情報を返します。
  return {
    id,
    filename,
    dependencies,
    code,
  };
}

// 一つのモジュールについて依存対象を抜き出せるようになったので、
// エントリーファイルの依存対象を抜き出していきます。
//
// それに続き、各依存対象が依存する対象を抜き出します。アプリケーションのすべての
// モジュールが互いにどのように依存しあっているのかを把握できるまで、上の工程を
// 繰り返します。このようにして得られるプロジェクトの全体像は、依存グラフと
// 呼ばれます。
function createGraph(entry) {
  // エントリーファイルのパースから始めます。
  const mainAsset = createAsset(entry);

  // すべてのアセットの依存対象をパースするためにキューを使います。そのために、
  // エントリーアセットのみを含む配列を定義します。
  const queue = [mainAsset];

  // `for ... of` ループによりキューを走査します。最初はキューには一つの
  // アセットしか含まれていませんが、繰り返しごとに新しいアセットをキューに
  // 追加していきます。このループは、キューから取り出す値がなくなったところで
  // 終了します。
  // (訳注: このコメントブロックの最後の文は、原文では"This loop will terminate
  // when the queue is empty." となっているが、queue が空になることはないため、
  // 表現を変更している)
  for (const asset of queue) {
    // すべてのアセットは、自身の依存対象への相対パスを保持しています。
    // それらを繰り返し取得し、`createAsset()` 関数によりパースし、
    // このモジュールの依存対象を下のオブジェクトにより記録します。
    asset.mapping = {};

    // このモジュールが含まれるディレクトリを表します。
    const dirname = path.dirname(asset.filename);

    // 依存対象への相対パスを走査します。
    asset.dependencies.forEach(relativePath => {
      // `createAsset()` 関数はファイルへの絶対パスを必要とします。一方、
      // 依存対象を保持する配列は相対パスの配列となっています。これらのパスは、
      // インポートする側のファイルに対する相対パスです。この相対パスを親の
      // アセットのディレクトリと結合することで、絶対パスが得られます。
      const absolutePath = path.join(dirname, relativePath);

      // アセットをパースし、内容を読み込み、依存対象を抜き出します。
      const child = createAsset(absolutePath);

      // 「アセット」が「子」に依存していると理解することは重要です。この関係を
      // 表現するために、`mapping` オブジェクトに新しいプロパティを追加し、
      // その値を子の id とします。
      asset.mapping[relativePath] = child.id;

      // 最後に、子のアセットをキューへと追加することで、依存対象自体も
      // パースされるようにします。
      queue.push(child);
    });
  }

  // この時点でキューは、ターゲットとなるアプリケーションに含まれるすべての
  // モジュールの配列となっています。これがグラフを表現したものとなります。
  return queue;
}

// 次に、グラフを使用して、ブラウザで実行可能なバンドルを返す関数を定義します。
//
// バンドルは、自身を実行する関数を一つだけもちます:
//
// (function() {})()
//
// 上の関数は、グラフに含まれるすべてのモジュールについての情報を保持する
// オブジェクトを、唯一のパラメータとします。
function bundle(graph) {
  let modules = '';

  // 関数の本体に取り掛かる前に、パラメータとして与えるオブジェクトを作成します。
  // ここで作成する文字列は二つの波括弧 ({}) に包まれるため、すべての
  // モジュールについて `key: value,` という形式の文字列を追加するという点に
  // 注意してください。
  graph.forEach(mod => {
    // グラフに含まれるすべてのモジュールはこのオブジェクトの要素となります。
    // ここではモジュールの id をキーとし、配列をその値とします (モジュール
    // ごとに二つの値をもちます)。
    //
    // 最初の値は、関数により包まれたモジュールのコードです。このようにするのは、
    // モジュールがスコープをもつべきだからです。あるモジュールで定義された変数が、
    // 他のモジュールやグローバルスコープに影響を与えてはいけません。
    //
    // 私たちのモジュールは、トランスパイルされたあと、CommonJS の
    // モジュールシステムを使用します。すなわち、トランスパイルされたコードは、
    // `require`、`module`、`exports` オブジェクトが使用可能であることを
    // 前提としています。これらは普通はブラウザで使用できないため、自ら実装し、
    // 関数のラッパーに注入します。
    //
    // 二つ目の値は、モジュールとその依存対象のマッピングを文字列化したもの
    // となります。これは次のようなオブジェクトです:
    // { './relative/path': 1 }.
    //
    // このようにするのは、トランスパイルされたモジュールのコードが相対パスを用いて
    // `require()` を呼び出すためです。この関数が呼び出された際に、グラフの中の
    // どのモジュールが、このモジュールで使用された相対パスと対応するのかを
    // 知る必要があるのです。
    modules += `${mod.id}: [
      function (require, module, exports) {
        ${mod.code}
      },
      ${JSON.stringify(mod.mapping)},
    ],`;
  });

  // 最後に、自身を実行する関数の本体を実装します。
  //
  // まず `require()` 関数を作成します。この関数はモジュールの id を受け取り、
  // 上で作成した `modules` オブジェクトからその値を見つけます。二つの値を
  // もつ配列から、関数のラッパーとマッピングオブジェクトを分割代入します。
  //
  // モジュールのコードでは、モジュールの id ではなく、相対パスを用いて
  // `require()` を呼び出します。一方、私たちの require 関数はモジュール id を
  // 受け付けます。また、二つのモジュールで同じ相対パスを `require()` していても、
  // 実際は異なるモジュールを意味しているかもしれません。
  //
  // これに対処するため、あるモジュールが require された際に、それが使用する
  // 専用の `require` 関数を新しく定義します。これはそのモジュール専用であり、
  // モジュールのマッピングオブジェクトを使用して相対パスを id へと変換します。
  // マッピングオブジェクトはまさにそういうものであり、相対パスと特定の
  // モジュールの id を対応付けるものなのです、
  //
  // 最後に、CommonJS において、モジュールが require された場合、`exports`
  // オブジェクトの変更を通じて値を外部に渡します。`exports` オブジェクトは、
  // モジュールのコードによって変更されたあと、`require()` 関数から返されます。
  const result = `
    (function(modules) {
      function require(id) {
        const [fn, mapping] = modules[id];

        function localRequire(name) {
          return require(mapping[name]);
        }

        const module = { exports : {} };

        fn(localRequire, module, module.exports);

        return module.exports;
      }

      require(0);
    })({${modules}})
  `;

  // シンプルに結果を返します、やりました！:)
  return result;
}

const graph = createGraph('./example/entry.js');
const result = bundle(graph);

console.log(result);
